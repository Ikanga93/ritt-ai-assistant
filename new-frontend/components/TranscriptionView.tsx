import useCombinedTranscriptions from "@/hooks/useCombinedTranscriptions";
import * as React from "react";
import type { JSX } from 'react';
import { useLocalParticipant, useRoomContext } from "@livekit/components-react";
import { PaymentButton } from "./PaymentButton";

// Define types for transcriptions
interface Transcription {
  role: string;
  id: string;
  text: string;
  language: string;
  startTime: number;
  endTime: number;
  final: boolean;
  firstReceivedTime: number;
  lastReceivedTime: number;
  receivedAtMediaTimestamp: number;
  receivedAt: number;
}

// Helper function to extract payment URLs from text messages
function extractPaymentUrl(text: string): string {
  if (!text) return '';
  
  // Log the text we're trying to extract a URL from
  console.log("\n=== EXTRACTING PAYMENT URL ===");
  console.log("Full text:", text);
  
  // First check for payment_link: format as it's the most specific
  // This is the format generated by the backend: payment_link:https://...
  const paymentLinkPattern = /payment_link:\s*(https?:\/\/\S+)/i;
  const paymentLinkMatch = text.match(paymentLinkPattern);
  if (paymentLinkMatch && paymentLinkMatch[1]) {
    // Trim the URL and remove any trailing punctuation that might have gotten captured
    const url = paymentLinkMatch[1].trim().replace(/[.,;:!?]+$/, '');
    console.log("Found payment_link format:", url);
    return url;
  }
  
  // Also check for messages that might contain only the payment_link: prefix with no URL
  if (text.includes('payment_link:')) {
    console.log("Found payment_link prefix but no valid URL");
    // This is a debug step to see what's happening with payment_link messages
    console.log("Text containing payment_link:", text);
    
    // Try a more permissive regex to handle potential formatting issues
    const permissiveMatch = text.match(/payment_link:[\s]*([\S]+)/i);
    if (permissiveMatch && permissiveMatch[1]) {
      let url = permissiveMatch[1].trim();
      if (!url.startsWith('http')) {
        url = 'https://' + url;
      }
      console.log("Found payment URL with permissive regex:", url);
      return url;
    }
  }
  
  // Check for Stripe payment links specifically - handles different Stripe domains
  const stripeLinkRegex = /(https?:\/\/(?:buy|checkout|pay)\.stripe\.com\/(?:test_)?[a-zA-Z0-9_]+)/i;
  const stripeLinkMatch = text.match(stripeLinkRegex);
  if (stripeLinkMatch && stripeLinkMatch[1]) {
    const url = stripeLinkMatch[1].trim();
    console.log("Found Stripe payment link:", url);
    return url;
  }
  
  // Check for any URL in the message as a last resort
  const urlRegex = /(https?:\/\/(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_\+.~#?&//=]*))/g;
  const matches = text.match(urlRegex);
  
  if (matches && matches.length > 0) {
    // Find the first URL that looks like a payment link
    const paymentUrl = matches.find(url => 
      url.includes('stripe.com') || 
      url.includes('checkout.stripe') ||
      url.includes('buy.stripe') ||
      url.includes('pay.stripe')
    );
    
    if (paymentUrl) {
      console.log("Found payment URL in message:", paymentUrl);
      return paymentUrl;
    }
    
    // If the message is clearly payment-related, return the first URL
    if (text.toLowerCase().includes('payment') || 
        text.toLowerCase().includes('pay now') || 
        text.toLowerCase().includes('checkout')) {
      console.log("Message is payment-related, using first URL found:", matches[0]);
      return matches[0];
    }
  }
  
  console.log("No valid payment URL found in text");
  return '';
}

export default function TranscriptionView(): JSX.Element {
  const combinedTranscriptions = useCombinedTranscriptions();
  const room = useRoomContext();
  const { localParticipant } = useLocalParticipant();
  
  // State to store the extracted payment URL
  const [paymentUrl, setPaymentUrl] = React.useState<string>('');
  const [lastProcessedMessageId, setLastProcessedMessageId] = React.useState<string>('');

  // Extract payment link from messages when transcriptions change
  React.useEffect(() => {
    // Skip if no new messages
    if (combinedTranscriptions.length === 0) return;
    
    console.log("Checking ALL messages for payment links, not just the last one");
    
    // First, check if there's a dedicated payment_link: message anywhere
    // This is important because the payment_link: message might be separate
    const paymentLinkMessage = combinedTranscriptions.find(t => 
      t.text && t.text.startsWith('payment_link:')
    );
    
    if (paymentLinkMessage) {
      console.log("Found raw payment_link message:", paymentLinkMessage.text);
      
      // Try the most specific format first: payment_link:https://...
      const paymentLinkMatch = paymentLinkMessage.text.match(/payment_link:\s*(https?:\/\/\S+)/i);
      if (paymentLinkMatch && paymentLinkMatch[1]) {
        // Clean up the URL by trimming and removing trailing punctuation
        const url = paymentLinkMatch[1].trim().replace(/[.,;:!?]+$/, '');
        console.log("Found dedicated payment link message:", url);
        setPaymentUrl(url);
        return;
      }
      
      // If that fails, try a more permissive pattern that can handle various Stripe URL formats
      const testLinkMatch = paymentLinkMessage.text.match(/payment_link:\s*((?:https?:\/\/)?(?:[^\s]+\.stripe\.com\/(?:test_)?[a-zA-Z0-9_]+|[^\s]+))/i);
      if (testLinkMatch && testLinkMatch[1]) {
        let url = testLinkMatch[1].trim().replace(/[.,;:!?]+$/, '');
        if (!url.startsWith('http')) {
          url = 'https://' + url;
        }
        console.log("Found payment link with permissive pattern:", url);
        setPaymentUrl(url);
        return;
      } else {
        // Log the failure to extract a URL
        console.error("Found payment_link message but couldn't extract URL:", paymentLinkMessage.text);
      }
    }
    
    // If no dedicated payment message, check all messages
    let found = false;
    
    // Loop through all messages in reverse (newest first)
    for (const message of [...combinedTranscriptions].reverse()) {
      if (!message.text) continue;
      
      // Only process messages we haven't seen yet
      if (message.id === lastProcessedMessageId) break;
      
      console.log("Checking message for payment URLs:", message.text);
      
      // First check if this is a payment link message with the specific format payment_link:URL
      const paymentLinkMatch = message.text.match(/payment_link:\s*(https?:\/\/\S+)/i);
      
      if (paymentLinkMatch && paymentLinkMatch[1]) {
        const url = paymentLinkMatch[1].trim().replace(/[.,;:!?]+$/, '');
        console.log("Found payment link in message:", url);
        setPaymentUrl(url);
        setLastProcessedMessageId(message.id);
        found = true;
        break;
      }
      
      // Then check if there's any URL in the message
      const extractedUrl = extractPaymentUrl(message.text);
      if (extractedUrl) {
        console.log("Extracted payment URL from message:", extractedUrl);
        setPaymentUrl(extractedUrl);
        setLastProcessedMessageId(message.id);
        found = true;
        break;
      }
    }
    
    if (!found) {
      console.log("No payment URL found in any message");
      // Do not set a hardcoded demo URL
    }
  }, [combinedTranscriptions, lastProcessedMessageId, paymentUrl]);

  React.useEffect(() => {
    const transcription = combinedTranscriptions[combinedTranscriptions.length - 1];
    if (transcription) {
      const transcriptionElement = document.getElementById(transcription.id);
      if (transcriptionElement) {
        transcriptionElement.scrollIntoView({ behavior: "smooth" });
      }
    }
  }, [combinedTranscriptions]);

  // Check if we should show a payment button for a specific message
  // Note: we're not showing message-specific buttons anymore, only the floating one at the top
  const shouldShowPaymentButton = (messageText: string) => {
    // Always return false as we don't display per-message payment buttons
    return false;
  };

  // Format message text, handling payment links
  const formatMessageText = (text: string) => {
    if (!text) return '';
    
    // Handle payment link messages - we'll skip these in the render function
    if (text.startsWith('payment_link:')) {
      // Return empty string for payment_link messages as we don't want to show them in the chat
      return '';
    }
    
    return text;
  };
  
  // Check if message contains a payment link
  const containsPaymentLink = (text: string) => {
    if (!text) return false;
    return text.startsWith('payment_link:') || 
           text.includes('stripe.com') || 
           text.includes('checkout.stripe.com') ||
           text.includes('buy.stripe.com') ||
           text.includes('pay.stripe.com');
  };

  // Log all transcriptions to debug payment link messages
  React.useEffect(() => {
    console.log("\n=== ALL TRANSCRIPTIONS ===");
    combinedTranscriptions.forEach((t, i) => {
      if (t.text.includes("payment")) {
        console.log(`Message ${i}:`, { id: t.id, role: t.role, text: t.text });
      }
    });
    
    if (paymentUrl) {
      console.log("Current payment URL:", paymentUrl);
    }
  }, [combinedTranscriptions, paymentUrl]);
  
  return (
    <div className="flex flex-col gap-4 p-4 overflow-y-auto h-full">
      {/* Render a single payment button at the top if we have a payment URL */}
      {paymentUrl && (
        <div className="sticky top-0 z-10 flex justify-center py-2 bg-white/80 backdrop-blur-sm rounded-md shadow-sm">
          <div className="bg-green-100 p-4 rounded-lg text-center max-w-sm">
            <p className="font-medium text-green-800 mb-2">Ready to complete your order?</p>
            <PaymentButton paymentLink={paymentUrl} />
          </div>
        </div>
      )}
      
      {combinedTranscriptions.map((transcription) => {
        const isFromServer = transcription.role === 'assistant';
        
        // Skip rendering payment_link messages in the chat
        if (transcription.text && transcription.text.startsWith('payment_link:')) {
          console.log("Found and skipping payment_link message:", transcription.text);
          return null; // Don't render this message
        }
        
        // Don't render empty messages (especially after formatting removed payment links)
        if (!formatMessageText(transcription.text)) {
          return null;
        }
        
        return (
          <div
            key={transcription.id}
            id={transcription.id}
            className={`flex ${isFromServer ? "justify-start" : "justify-end"}`}
          >
            <div
              className={`rounded-lg p-3 max-w-[80%] ${
                isFromServer ? "bg-gray-200 text-black" : "bg-blue-500 text-white"
              }`}
            >
              <div className="flex flex-col gap-2">
                <div className={containsPaymentLink(transcription.text) ? 'break-all' : ''}>
                  {formatMessageText(transcription.text)}
                </div>
              </div>
            </div>
          </div>
        );
      })}
    </div>
  );
}
